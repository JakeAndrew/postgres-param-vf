{-# LANGUAGE OverloadedStrings #-}

--  | sdb: Stands for "_S_nowdrift _d_ata_b_ase [command]".
-- (This file is sdb.hs.)
--  Scroll down to "usageText" for more info.

-- Code notes:
--
-- * Original idea taken from https://git.gnu.io/snippets/3
-- * underscore_names are used for functions that mimic shell commands.
-- * I intentionally did not use Turtle.Options nor optparse-applicative.
--   The autogenerated help text is no good.

import Prelude hiding (FilePath)

import Control.Exception.Base (bracket)
import Data.Text (Text)
import Development.Shake
import GHC.IO.Handle (hDuplicate, hDuplicateTo)
import System.Environment (getProgName, getArgs)
import System.IO (openFile, IOMode(..))
import Turtle hiding (need, opt)
import qualified Data.Text as T
import qualified Filesystem.Path.CurrentOS as P
import qualified System.IO as H
import qualified Turtle

pgWorkDir :: FilePath
pgWorkDir = ".postgres-work"  -- This is where we put the database files.
                              -- At time of writing, we place this directory
                              -- right in the project root.
data Databases = DBS { dbsMain :: Text, dbsTest :: Text }

dbnames :: Databases
dbnames = DBS "snowdrift" "snowdrift_test"

-- "this" is the name of the binary executable file, which, at time of writing,
-- is "sdb". However, the user is expected to always launch the binary through
-- a wrapper script: "sdb.sh", at time of writing. See the "where" clause below.
usageText :: Line -> Shell ()
usageText this = mapM_ err
    [ scriptName <> ": provides basic control over the Snowdrift database server,"
    , "such as starting and stopping."
    , ""
    , "Please see BUILD.md and \"build.sh help\": sometimes you need to run"
    , "build.sh instead of \"" <> scriptName <> " start\". That doc will tell you\
     \ when."
    , ""
    , "Usage:"
    , ""
    , "    " <> scriptName <> " ACTION"
    , ""
    , "Where ACTION may be one of:"
    , ""
    , "    clean             \"rm -rf\" the whole cluster"
    , "                             Note: this also terminates the server"
    , "                             process."
    , ""
    , "    help              print this text"
    , ""
    , "    env               print export commands for PGHOST and PGDATA"
    , "                             e.g. 'source <(" <> scriptName <> " env)'"
    , ""
    , "    start             start the cluster"
    , "                             Note: this automatically sets up environment"
    , "                             variables and the dev/test databases for"
    , "                             hacking on the Snowdrift.coop website."
    , ""
    , "    stop              stop the cluster"
    ]
    where scriptName = this <> ".sh"

dbRunning, dbCluster :: H.FilePath
dbRunning = ".postgres-work/data/postmaster.pid"
dbCluster = ".postgres-work/data/postgresql.conf"

-- | This is the main part of the program.
-- It used to be the entire program (main). But now, in main, we do an error
-- trap, and, if sucessful, pass mainPart its parameter.
-- See the comments in main.
mainPart :: Text -> IO ()
-- dbParent stands for "database parent directory". This is where we
-- place .postgres-work, the database directory.
-- Read the comments in admin-tools/sdb.sh for more info.
mainPart dbParent = sh $ do

    (pghost, pgdata) <- initEnv dbParent -- Just keep passing dbParent.

    -- An escape hatch before getting down to shake
    args <- liftIO getArgs
    case args of
        ["env"] -> do
            printExport "PGHOST" (toText_ pghost)
            printExport "PGDATA" (toText_ pgdata)
            printExport "PGDATABASE" (dbsMain dbnames)
        ("pg_ctl":as') -> procs "pg_ctl" (map T.pack as') empty
        _ -> liftIO (shakeit pghost pgdata)
  where
    printExport name val =

    -- Note the single quote added after the equals sign, and another added at
    -- the end:
        echo (mconcat ["export ", name, "='", unsafeTextToLine (escapeQuotes val), "'"])

    -- In addition to wrapping the path string in quotes (above), we're escaping
    -- any pre-existing single "quotes" in the path string, such as what may be
    -- used as apostrophes, e.g. "/Bob's Recipies/Eggs O'Brien.pdf"
    escapeQuotes = T.concatMap (\c -> if c == '\'' then "'\\''" else T.singleton c)

shakeit :: FilePath -> FilePath -> IO ()
shakeit pghost pgdata = shakeArgs shakeOptions $ do
    want ["help"]

    -- Very basic

    phony "help" $ actsh (usageText . unsafeTextToLine . T.pack =<< liftIO getProgName)

    phony "clean" $ do
        need ["stop"]
        removeFilesAfter ".postgres-work" ["//*"]

    phony "start" (need [dbRunning])

    phony "stop"
        (actsh (shell "pg_ctl status" empty .&&. shell "pg_ctl stop" empty))

    dbRunning %> const (do
        need [dbCluster]
        actsh (shell "pg_ctl status" empty .||. shell "pg_ctl -w start" empty)
        )

    dbCluster %> const (actsh (initCluster pghost pgdata))

initCluster :: FilePath -> FilePath -> Shell ()
initCluster pghost pgdata = do
    step "Creating directories..."
    mktree pghost
    mktree pgdata

    step "Initializing cluster..."
    hush $ procs "pg_ctl" ["initdb", "-o", "--nosync --auth=peer", "-D", pgdata'] empty

    step "Updating cluster configuration file..."
    setPgConfigOpts (pgdata </> "postgresql.conf")
        [ -- set the unix socket directory because pg_ctl start doesn't
          -- pay attention to PGHOST (wat.)
          ("unix_socket_directory", pghost')
        , ("unix_socket_directories", pghost')
        , ("archive_mode", "off")
        , ("fsync", "off")
        , ("wal_level", "minimal")
          -- don't bother listening on a port, just a socket.
        , ("listen_addresses", "''")
        ]

    step "Starting database server..."
    procs "pg_ctl" ["start", "-w"] empty

    step "Creating databases..."
    procs "createdb" [dbsMain dbnames] empty
    procs "createdb" [dbsTest dbnames] empty

    step "Success."

  where

    pghost'  = "'" <> toText_ pghost <> "'"
    pgdata'  = toText_ pgdata
    setPgConfigOpts config opts =
        inplace_ (choice (patterns opts)) config
    patterns opts =
        map (fmap Just . uncurry optSettingPattern) opts
        <> [ commentOrEmpty >> pure Nothing ]
    commentOrEmpty :: Pattern Text
    commentOrEmpty =
        contains (begins spaces >> (T.singleton <$> (char '#' <|> newline)))
    optSettingPattern opt value = do
        -- match the line with the option
        _ <- contains $ do
            void $ begins (star (oneOf " #"))
            void $ text opt
            once (oneOf " =")
        -- replace it with 'opt = value'
        return (opt <> " = " <> value)

-- | Create and export some env variables
initEnv :: Text -> Shell (FilePath, FilePath)
initEnv dbParent = do  -- See comments above and in mainPart.
    Just path <- Turtle.need "PATH"
    pgPath <- lineToText <$> inshell "pg_config --bindir" ""
    let pghost = dbParent </> pgWorkDir </> "sockets"
        pgdata = dbParent </> pgWorkDir </> "data"
    export "PGHOST" (toText_ pghost)
    export "PGDATA" (toText_ pgdata)
    export "PGDATABASE" (dbsMain dbnames)
    export "PATH" (format (s%":"%s) path pgPath)
    return (pghost, pgdata)

main :: IO ()
main = do
    -- Turtle.need gets us a "maybe Text" value: it holds "Just" the character
    -- string from the envirnmental variable "dbParent", if it exists.
    -- If it does not, Turtle.need gives a "Nothing".
    maybeDbParent <- Turtle.need "dbParent"

    -- If we got the envirnmental variable, we pass it to mainPart.
    case maybeDbParent of Just dbParent -> mainPart dbParent

                          -- If not, we print an error to stderr and terminate.
                          Nothing -> noDbParentError

-- | Prints error message for if dbParent is not set. See comments in main.
noDbParentError :: IO ()
noDbParentError = H.hPutStrLn H.stderr
    "The sdb binary has been executed with no value given for the\n\
    \environmental variable, \"dbParent\", which tells where to put/look for\n\
    \the database directory. The variable is usually set by running sdb.sh,\n\
    \which also launches the sdb binary. At time of writing, sdb.sh comes in\n\
    \the admin-tools package.\n\
    \The dbParent variable has to be set for sdb to work."

-- ##
-- ## Helper functions/additions to underlying libs
-- ##

-- | Use a 'Shell a' as an 'Action ()'
actsh :: Shell a -> Action ()
actsh = liftIO . sh

-- | Print a header for a step
step :: Line -> Shell ()
step msg = err ("## " <> msg)

-- | Seeing as I use this everywhere
toText_ :: FilePath -> Text
toText_ = format fp

-- | inplace with filtering.
inplace_ :: MonadIO io => Pattern (Maybe Text) -> FilePath -> io ()
inplace_ pat file = liftIO (runManaged (do
    here              <- pwd
    (tmpfile, handle) <- mktemp here "turtle"
    outhandle handle (sed_ pat (input file))
    liftIO (H.hClose handle)
    mv tmpfile file ))

-- | sed with filtering.
sed_ :: Pattern (Maybe Text) -> Shell Line -> Shell Line
sed_ pat orig = flatten $ do
    when (matchesEmpty pat) (die message)
    let pat' = fmap mconcat
            (many (pat <|> fmap (Just . T.singleton) anyChar))
    txt    <- lineToText <$> orig
    txt':_ <- return (match pat' txt)
    return (unsafeTextToLine <$> txt')
  where
    message = "sed: the given pattern matches the empty string"
    matchesEmpty = not . null . flip match ""
    flatten my = do
        Just y <- my
        return y

-- | Run a shell and send stdout/stderr to nowhere
hush :: Shell () -> Shell ()
hush act = liftIO $ bracket
    (do
        saveErr <- hDuplicate H.stderr
        saveOut <- hDuplicate H.stdout
        h <- openFile "/dev/null" WriteMode
        hDuplicateTo h H.stderr
        hDuplicateTo h H.stdout
        return (saveErr, saveOut)
    )
    (\(saveErr, saveOut) -> do
        hDuplicateTo saveErr H.stderr
        hDuplicateTo saveOut H.stdout)
    (const (sh act))
